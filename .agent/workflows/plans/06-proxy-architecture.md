---
description: 프록시 전체 구성 기획 — 포워드/리버스, 호스트 파일 없이 브라우저·로컬 서버 연동
---

# 프록시 전체 구성 기획안

Watchtower 로컬 프록시의 **전체 구성·포트 역할·트래픽 흐름**을 정리한 기획 문서입니다.  
호스트 파일 없이 브라우저에서 로컬 서버를 띄우고, 로컬 서버에서 나가는 요청은 프록시를 거치도록 하는 방식을 설명합니다.

**관련 문서**: [05-domain-local-routing.md](05-domain-local-routing.md) (도메인 로컬 라우팅 필요 항목)

---

## 0. 설계 포인트 (핵심)

**“로컬로 보낼지 / 실제로 보낼지”는 항상 프록시 서버가 결정한다.** 클라이언트(로컬 서버·브라우저)는 “프록시로 보낼지”만 정하고, **대상 호스트를 로컬로 연결할지는 프록시가 판단**한다.

| 구분 | 클라이언트 의도 | 프록시 역할 |
|------|------------------|-------------|
| **로컬 서버** | **외부 API**로 요청을 보내려 함 (예: `https://api.real.com/…`). 프록시를 “직접 호출”하려는 게 아님. | 요청이 프록시를 거치면, **대상 Host**를 로컬 라우트와 비교해 **로컬로 보낼지 / 실제 외부로 보낼지** 결정 후 전달. |
| **브라우저** | 사용자가 주소창에 도메인(또는 IP)을 입력해 요청. DNS로 주소를 풀 수 있음. | 브라우저가 **프록시를 사용**하면, 그 요청(대상 호스트)이 프록시로 들어옴. 프록시가 **리버스(로컬 전달)할지 / 패스스루(실제 서버)할지** 결정. 브라우저가 DNS에 물어보는 단계와 무관하게, **최종 HTTP/HTTPS 요청의 대상 호스트**를 보고 프록시가 결정. |

정리하면:

- **로컬 서버**: “외부 API 호출”을 보내고, 프록시를 경유하면 **프록시가** “이 Host는 로컬 라우트다 → 로컬로 연결 / 아니다 → 실제로 연결” 한다.
- **브라우저**: 어떤 도메인(호스트)으로 요청하든, 그 요청이 프록시를 거칠 때 **프록시가** “리버스(로컬로 보낼지) / 패스스루(실제로 보낼지)” 를 결정한다. (DNS 서버에 물어보는 것과 별개로, 프록시에 도달한 요청의 대상 호스트 기준으로 판단.)

---

## 1. 목표 정리

| 목표 | 설명 |
|------|------|
| **Windows 시스템 프록시 설정 없이 사용** | 브라우저에 “프록시 사용”을 넣지 않고, 프록시 서버 주소로 직접 접속해 로컬 앱을 본다. |
| **브라우저 → 로컬 서버** | 브라우저가 **프록시(리버스 포트)** 로 요청 → 프록시가 **로컬 서버**로 전달. |
| **로컬 서버 → 실제 API** | 로컬 서버(앱)가 외부 API를 부를 때 **프록시(포워드 포트)** 를 쓰면, 프록시가 실제 서버로 연결한다. |
| **설정 전달** | 브라우저에서 로컬 서버 화면을 보여주고, 그 **로컬 서버 앱이 “프록시 주소·설정”** 을 안내한다. (호스트 파일 편집 불필요) |

---

## 2. 전체 구성도

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Watchtower 프록시 (127.0.0.1)                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────────────┐  ┌──────────────────────┐  ┌────────────────┐ │
│  │ 포워드 프록시         │  │ 리버스 HTTP          │  │ 리버스 HTTPS   │ │
│  │ (예: 3300 / 8888)     │  │ (예: 8080)           │  │ (예: 8443)     │ │
│  │                      │  │                      │  │                │ │
│  │ • CONNECT(HTTPS) 지원 │  │ • Host/127.0.0.1 기준│  │ • TLS 종료     │ │
│  │ • Host 기준 라우팅    │  │   → 로컬 라우트 전달 │  │ • Host 기준    │ │
│  │ • 로컬 라우트면       │  │ • 호스트 파일 불필요 │  │   → 로컬 전달  │ │
│  │   TLS 종료 후 전달    │  │   (127.0.0.1 → 1번   │  │                │ │
│  │ • 그 외 패스스루      │  │   라우트로 전달)     │  │                │ │
│  └──────────┬───────────┘  └──────────┬───────────┘  └───────┬──────────┘ │
│             │                          │                      │           │
│             │  로컬 라우트 테이블 (도메인 → target_host:port) │           │
│             └──────────────────────────┼──────────────────────┘           │
│                                       ▼                                   │
│                          로컬 서버 (예: 127.0.0.1:3100)                   │
└─────────────────────────────────────────────────────────────────────────┘

  [브라우저]                    [로컬 서버 앱]
       │                             │
       │  http://127.0.0.1:8080/     │
       │  (리버스 HTTP)              │
       │ ──────────────────────────► │  GET / → 로컬 앱 응답
       │                             │  (앱이 “프록시 127.0.0.1:3300 사용” 안내 가능)
       │                             │
       │                             │  fetch('https://api.real.com/…')
       │                             │  → HTTP_PROXY=127.0.0.1:3300
       │                             │ ──────────────────────────► [실제 API]
       │                             │  (포워드 프록시가 연결)
```

---

## 3. 포트 역할

| 포트 종류 | 설정 필드 | 기본 예시 | 역할 |
|-----------|------------|-----------|------|
| **포워드 프록시** | `proxy_port` | 8888 / 3300 | 클라이언트(로컬 서버·스크립트)가 **HTTP_PROXY** 로 지정. CONNECT(HTTPS) 포함, Host 기준 로컬 라우트 또는 패스스루. |
| **리버스 HTTP** | `reverse_http_port` | 8080 (옵션) | 브라우저가 **직접 접속** (예: `http://127.0.0.1:8080`). Host가 127.0.0.1/localhost면 **호스트 파일 없이** 첫 번째 로컬 라우트로 전달. |
| **리버스 HTTPS** | `reverse_https_port` | 8443 (옵션) | 브라우저가 **직접 접속** (예: `https://127.0.0.1:8443`). TLS 종료 후 Host 기준 로컬 라우트 전달. (동적 인증서) |

- 리버스 포트를 **사용하지 않으면** 기존처럼 “시스템/브라우저 프록시 = 포워드 포트”만 써도 됨.
- 리버스 포트를 **쓰면** 호스트 파일 없이 `http://127.0.0.1:리버스포트` 로 로컬 앱 접속 가능.

---

## 4. 트래픽 흐름 (시나리오)

### 4.1 브라우저 요청 — 프록시가 리버스(로컬) 여부 결정

브라우저가 어떤 도메인(호스트)으로 요청하든, **그 요청이 프록시를 거치면** 프록시가 대상 Host를 보고 **리버스(로컬로 전달)할지 / 패스스루(실제 서버로)할지** 결정한다. (브라우저가 DNS로 주소를 묻는 단계와 무관하게, 프록시에 도달한 요청의 Host 기준으로 판단.)

**호스트 파일 없이 로컬 앱 보기 (리버스 HTTP 예):**

1. 사용자가 **리버스 HTTP 포트**(예: 8080)를 설정하고 프록시를 기동.
2. 로컬 라우트가 하나 이상 있고, 그 중 하나가 `dev.modetour.local` → `127.0.0.1:3100` 이라고 가정.
3. 사용자가 브라우저에서 **`http://127.0.0.1:8080/`** 접속.
4. **프록시가** `Host: 127.0.0.1:8080` 를 보고, **127.0.0.1 = 첫 번째 로컬 라우트** 규칙에 따라 `127.0.0.1:3100` 으로 전달.
5. 로컬 서버(3100)가 응답을 반환하면, 브라우저에는 로컬 앱 화면이 보임.
6. 로컬 앱이 “API 호출 시 **HTTP_PROXY=127.0.0.1:3300** 사용” 같은 설정 안내를 화면에 노출하면, 사용자가 로컬 서버 측만 설정하면 됨.

**브라우저가 포워드 프록시를 쓸 때:**  
주소창에 `https://dev.modetour.local` 등을 입력하면, 요청이 포워드 프록시로 가고, **프록시가** Host `dev.modetour.local` 을 로컬 라우트와 비교해 로컬로 보낼지·실제로 보낼지 결정한다.

### 4.2 로컬 서버의 “외부 API” 요청 — 프록시가 로컬/실제 결정

1. 로컬 서버(예: Node/Next 등)는 **외부 API를 호출**하려고 요청을 보냄 (예: `https://api.real.com/…`). 프록시를 “직접 호출”하려는 의도가 아님.
2. 로컬 서버가 **HTTP_PROXY** 로 포워드 프록시(3300)를 쓰도록 되어 있으면, 그 요청이 **포워드 프록시**로 들어감.
3. **프록시가** 요청의 대상 Host(`api.real.com` 등)를 보고 **로컬 라우트 테이블과 비교**:
   - 로컬 라우트에 있으면 → **로컬** `target_host:port` 로 전달.
   - 없으면 → **패스스루** 로 실제 외부 서버에 연결.

즉,  
- **브라우저 → 로컬**: 리버스 포트(8080)로 접속 시, 프록시가 Host/127.0.0.1을 보고 로컬로 전달할지 결정.  
- **로컬 → “외부 API”**: 요청이 프록시를 거치면, **프록시가** Host를 보고 로컬로 보낼지·실제로 보낼지 결정.

---

## 5. 라우팅 규칙 요약 (프록시 서버 내부)

**로컬로 보낼지 / 실제로 보낼지는 모두 프록시 서버가 여기 규칙으로 결정한다.** (로컬 서버·브라우저는 “어디로 요청할지”만 정하고, “그걸 로컬로 갈지 실제로 갈지”는 프록시가 정함.)

| 조건 | 동작 |
|------|------|
| Host가 **로컬 라우트 도메인**과 일치 (enabled) | 해당 `target_host:target_port` 로 전달. |
| Host가 **127.0.0.1** 또는 **localhost** (포트 제거 후 비교) | **호스트 파일 없이** 첫 번째 enabled 로컬 라우트로 전달. (리버스 접속용) |
| 그 외 | 패스스루(포워드 프록시인 경우) 또는 해당 Host로 전달. |

CONNECT(HTTPS)의 경우:

- Host가 로컬 라우트면: 프록시에서 **TLS 종료** 후 로컬 백엔드(HTTP)로 전달.
- 로컬 라우트가 아니면: 기존처럼 터널만 유지.

---

## 6. 설정·데이터 (요약)

- **ProxySettings**  
  - `proxy_port`: 포워드 프록시 포트.  
  - `reverse_http_port`, `reverse_https_port`: 옵션. 설정 시 기동 시 해당 포트도 리스닝.  
  - `dns_server`: 패스스루 시 DNS(옵션).
- **LocalRoute**  
  - `domain`, `target_host`, `target_port`, `enabled` — 도메인 → 로컬 주소 매핑.
- **동작**  
  - 프록시 기동 시: 포워드 포트 필수, 리버스 HTTP/HTTPS 포트는 설정된 것만 리스닝.  
  - 중지 시: 모든 리스너 일괄 중지.

---

## 7. “설정 전달” 흐름 (브라우저 ↔ 로컬 서버)

- **브라우저**는 `http://127.0.0.1:리버스포트` 로만 접속하면 됨. (시스템 프록시 설정 불필요.)
- **로컬 서버 앱**이 그 요청에 대한 응답으로 HTML/UI를 주고, 그 안에  
  “이 환경에서는 API 호출 시 **프록시 `127.0.0.1:포워드포트`** 를 사용하세요” 같은 안내를 넣을 수 있음.
- 필요하면 로컬 앱이 **환경 변수 예시** (`HTTP_PROXY`, `HTTPS_PROXY`) 또는 “개발용 프록시 주소” 문자열을 노출하면, 사용자나 다른 툴이 그걸 복사해 쓰면 됨.

호스트 파일은 **전혀 건드리지 않아도** 위 흐름이 동작하도록 구성한 것이 이 기획의 요지입니다.

---

## 8. 향후 확장 (05와의 관계)

- [05-domain-local-routing.md](05-domain-local-routing.md) 의 “미래 확장 (B·C 시나리오)” 에서 말한  
  **0.0.0.0 바인딩, TLS(CA·인증서), SSL 다운로드, QR/외부 URL** 은 그대로 적용 가능.
- 현재는 **127.0.0.1 전용**, **리버스 포트는 옵션**으로 두고,  
  “호스트 파일 없이 127.0.0.1/localhost → 첫 번째 로컬 라우트” 규칙으로 브라우저·로컬 서버 연동을 맞춰 두었음.
- 이후 같은 라우팅 테이블과 TLS 종료 로직을 그대로 두고, 바인딩 주소·인증서 배포만 확장하면 됨.
- **QR 코드 (Android / iPhone)**: 설정 페이지 URL(예: `http://{LAN_IP}:8080/.watchtower/setup`)을 QR로 노출하면, 모바일에서 스캔해 같은 설정 페이지(SSL 다운로드·프록시 설정)로 연결 가능. 이때 리버스 포트를 **0.0.0.0**으로 열고, LAN IP를 구해 URL을 만들어야 함. 자세한 세팅은 [07-proxy-setup-page-feasibility.md](07-proxy-setup-page-feasibility.md) §8 참고.

---

## 9. 체크리스트 (구현 대비)

| 구분 | 항목 | 비고 |
|------|------|------|
| BE | 포워드 프록시 (proxy_port), CONNECT 시 로컬 라우트 TLS 종료 | 구현됨 |
| BE | 리버스 HTTP/HTTPS 리스너 (reverse_http_port, reverse_https_port) | 구현됨 |
| BE | Host = 127.0.0.1 / localhost → 첫 번째 로컬 라우트 | 구현됨 |
| BE | ProxySettings.reverse_* 저장·설정 API | 구현됨 |
| FE | 리버스 포트 설정 UI, 사용 안내 문구 (127.0.0.1:리버스포트 접속 안내) | 필요 시 보강 |
| 문서 | 이 기획안으로 팀/스스로와 소통 후, 05·03 등과 정합성 맞추기 | 본 문서 |

---

이 문서로 전체 구성을 맞춘 뒤, 세부 UI·에러 메시지·설정 화면 문구 등을 정리하면 됩니다.
